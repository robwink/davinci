load_module("gui")
top=gui.create("topLevelShell",name="test_scrolledwindow.dv",resources={width=500,height=500})
wid=gui.create("scrolledwindow",top)
string="The ScrolledWindow Design Model - The user always interacts with a ScrolledWindow through ScrollBars. Internally, however, there are several ways to implement what the user sees. These methods are based on two different scrolling models: automatic scrolling and application-defined scrolling. In either case, the application gives the ScrolledWindow a work window that contains the visual data to be viewed. Although the two models are different, they share many of the same concepts and features. In automatic scrolling mode, the ScrolledWindow operates entirely on its own, adjusting the viewport as necessary in response to ScrollBar activity. The application simply creates the desired data, such as a Label widget that contains a large pixmap, and makes that widget the work window for the ScrolledWindow. When the user operates the ScrollBars to change the visible area, the ScrolledWindow adjusts the Label so that the appropriate portion is visible. This design is demonstrated in Chapter 4, The Main Window, and Chapter 11, The DrawingArea Widget. With application-defined scrolling, the ScrolledWindow operates under the assumption that the work window is not complete. The widget assumes that another entity, such as the application or the internals of another widget, controls the data within the work window and that the data may change dynamically as the user scrolls. In order to control scrolling, the application must control all aspects of the ScrollBars. This level of control is necessary when it is impossible or impractical for an application to provide the ScrolledWindow with a sufficiently large work window (or the data for it) at any one time.";
text=gui.create("text",wid,{value=string});
gui.set(text,{cursorPosition=length(gui.get(text,"value").value)})
gui.realize(top)

