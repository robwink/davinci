XfCreateVisual - Create a visual
XfFreeVisual - Free memory owned by visual
XfCreatePB	- Create a pushbutton

XfCreateVisual(Any, x, y, width, height, foreground, background, type, ...)
    XfAny Any;
    int x,y;
    int width,height;
    short foreground, background;
    int type;

XfCreateVisual is used to create a visual for use in any of the tool types.
There are 8 different visual types, each taking a different number and type
of arguments, beyond the standard arguments listed above.  The visual types 
and the additional arguments expected for each type are:

    XfSolidVisual:      int type)           /* No additional args */
        Solid produces a filled rectangle of color foreground.  If height
        or width is 0, then the height/width of the passed tool is used.
        (This allows for x,y,width,height of 0,0,0,0 to cover the whole tool)

    XfPixmapVisual:     int type, int depth, Pixmap map)
        Pixmap copies a standard X Pixmap to the designated x,y coordinates.
        The height and width parameters are not used for clipping the pixmap,
        but rather are used as an indication of the size of the pixmap to 
        expect.   There is no provision for clipping a pixmap built into the
        tool.  (If height and width are different than the actual height and
        width of the pixmap, unexpected results may occur.)
        
        If depth is passed as 1, then a character string is expected for map,
        rather than a pixmap.  (This is misnamed in this case and should be
        XfBitmapVisual, to avoid confusion)

    XfTextVisual:       int type, char *text, Font font, int align)
        A text visual is used to display a text string.  There is a limit
        of 256 characters per visual.  There is no support for multi-line
        text strings.  Align is text justification, one of:
            0,  center justified
            1,  left justified
            2,  right justified

    XfXImageVisual:     int type, int depth, int format, char* data)
        XImageVisual is the XImage equivalent of PixmapVisual.  Format 
        is one of ZPixmap, XYPixmap or XYBitmap as defined in the
        XImage specifications.

    XfTiledVisual:       int type, Pixmap map)
        TiledVisual is a Tiled Solid (as defined by X standards)  This is
        simply a 2 color bitmap colored the background (0) and foreground 
        (1) colors.  If the bitmap is smaller than the area to be filed, 
        it is repeated.  (Height and width in this instance are the size of
        the area to be filled, not the size of the bitmap, as in PixmapVisual)

    XfStippledVisual:
    XfOpaqueStippledVisual:
          int type, char* data, int stipple_width, int stipple_height)

        These produce stippled and opaque stippled rectangular fills as 
        defined by the X standards.  A stipple is a 1 color bitmap, 0s 
        being masked out (transparent).  Opaque stipples are two color 
        bitmaps, similar to Tiles.  The difference between the stipple and
        tile calls is that tiles take an existing pixmap and stipples create
        their own from the passed character string.

    XfHersheyVisual:
          int type, char *text, int cset, float angle, float scale, int align);

        HersheyVisual is an text output using the hershey vector fonts.  This
        allows for arbitrarily rotated and scaled text.  'cset' is one of the
        19 ascii supported character subsets (fonts) included in the hershey
        fonts (defined in hershey.h):

            #define CYRILIC_COMPLEX        1
            #define GOTHIC_ENGLISH_TRIPLEX 2
            #define GOTHIC_GERMAN_TRIPLEX  3
            #define GOTHIC_ITALIAN_TRIPLEX 4
            #define GREEK_COMPLEX          5
            #define GREEK_COMPLEX_SMALL    6
            #define GREEK_PLAIN            7
            #define GREEK_SIMPLEX          8
            #define ITALIC_COMPLEX         9
            #define ITALIC_COMPLEX_SMALL   10
            #define ITALIC_TRIPLEX         11
            #define ROMAN_COMPLEX          12
            #define ROMAN_COMPLEX_SMALL    13
            #define ROMAN_DUPLEX           14
            #define ROMAN_PLAIN            15
            #define ROMAN_SIMPLEX          16
            #define ROMAN_TRIPLEX          17
            #define SCRIPT_COMPLEX         18
            #define SCRIPT_SIMPLEX         19

        The interface to access the non-ascii characters of the hershey fonts
        is still under development.  (there are another 800 characters that
        aren't letters or numbers, including musical, math, scientific, and
        astrological symbol sets as well as 3200 oriental characters)

Visual Implementation Notes
---------------------------

    Visuals are stored in a linked list inside each tool type.  This scheme
    insures that text placed over an image will always be rendered after the
    image has been updated.  (and consequently can't be covered over by the
    image.)  Unfortunately, this scheme also requires that a programmer know
    the structure of the visual list in order to be able to change visuals
    once they have been created and used.

    For instance, if you have:

        Solid->Stipple->Text

    The text will always be rendered last and therefore will always appear on
    top.  But in order to change the text once it has been created, you must
    use something like the following construct:

        strcpy(B->States[i]->Visuals->next->next->visual.t_vis.text, new_text);
    
    (Actually, you could, in this case, use SetButtonText() which would scan
    all the visuals of all the states of B (a button) and set them all to
    new_text, but it only works on buttons and it changes ALL the text strings
    in the button (usually not desired).

    In general it is icky to modify visuals after their creation, but it is
    not impossible.  (Suggestions welcomed for this stuff)



XfFreeVisual(display, struct VisualInfo *vis)

    XfFreeVisual frees all memory assocaited with a visual.
    (This includes Pixmaps and Images allocated at creation time)

    If a single pixmap is used by more than one visual, it should not be
    freed.  
    
    Note: XfDestroy* typically calls XfFreeVisual on all visuals a tool owns.
          If any of these visuals are used by more than one tool,
          unpredictable results may occur when tools are destroyed.


PUSHBUTTONS
-----------

PButton
XfCreatePB(display, parent, x, y, w, h, text, align, fs, pixmap, function)
	Display *display;
	Window parent;
	int x,y,w,h;	/* xpos, ypos, width, height */
	char *text;
	int align;		/* 0 = center, 1 = right, -1 = left */
	XFontStruct *fs;
	Pixmap pixmap;
	CallBack function(PButton);

XfCreatePB creates a pushbutton.  Pushbuttons are special purpose tools
that accept a mouse click from the user.  When the user releases the mouse
button on top of a pushbutton, the specified CallBack function is executed.

Pushbuttons are rendered in a 3-D style, with a text and/or Pixmap decoration.
When the user depresses the button, the 3-D style is inverted and the button 
is highlighted.

Pushbuttons have been designed to function with as little programmer 
intervention as possible.


XfActivatePB(PB, state)
	PButton PB;
	int state;		/* 0=normal, 1=depressed, -1=deactivated */

XfActivatePB maps the passed PButton to the screen, and sets it state.
This function should also be used to change a PB's state once it has
already been mapped to the screen.
