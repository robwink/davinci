?
 Intro

?operators

 Davinci provides the following mathematical and relational operators:

   Mathematical        Relational                   Arrays
   ---------------     ------------------------     --------------------
    + add              <  less than                 []     range
    - subtract         >  greater than              //     concatenation
    * multipy          <= less than or equal        where  partial replacement
    / divide           >= greater than or equal
    % modulo           == equal 
    = equvialence      != not equal
                       || logical OR
                       && logical AND


 All the mathematical operators except can take any two VAL types, and 
 will cast up to the larger type.

 All the relational operators return a value of 0 or 1.  If used on arrays,
 they return an array of 0's and 1's.

 Range, concatentaion and the where operator each have their own 
 pecularities.  Consult the individual help topics.

?operators //
?//
?concatenation

 The // operator concatenates (appends) two values together along their
 X axis.  It is shorthand for cat(v1, v2, x), and therefore has all
 the limitations of the cat() function.

 Example:
    This example creates a 3x1x1 array from the numbers 1, 2 and 3:

        dv> 1 // 2 // 3
        :       3x1x1 array of int, bsq format [12 bytes]
        1       2       3


?operators []
?[]
?range
 The unary range operator, [], extracts a subset of data from a VAL.
 The range operator can oply be applied to a named variable.
 The range operator takes up to three ranges, one for each axis, in the
 order X, Y, Z, of the form [low:hi:step].

 Any of the range values may be blank, indicating the least restrictive 
 value.  If the third or second and third values are blank, they may be
 completely omitted.

 Example:
     This example extracts a portion of the X axis, all the values along
     the Y axis, and the even values along the Z axis:

        dv> data[3:8, , 2::2]

?operators where
?where
?[where]
 The unary operator 'where', provides partial array replacement, based on
 a boolean expresion.  The 'where' operator can only be used during array
 assignment, and then, only on a named array.

 The syntax is as follows:

    array [ where expr1 ] = expr2

 Expr1 must evaluate to an array with the same organization and dimensions 
 as array, and where expr1 is true, the corresponding element of array is 
 replaced with the value of expr2.  Expr2 must be a single value.

 Example:
     This example replaces all values in data that are less than zero,
     with the value 0.

        dv> data[ where (data < 0) ] = 0

?functions
 Functions

?functions org()
?org()
 org() - Show or change an objects data organization

 org(object=VAL [,org={BIL,BIP,BSQ}])

    The org() function reports or changes the data organization of an
    object.  If used with only one argument, the data organization of
    the object specified is reported as a string.  The return values
    are one of:

        "bil" - Band interleaved by line (XZY)
        "bip" - Band interleaved by pixel (ZXY)
        "bsq" - Band sequential (XYZ)

    If the second, optional, argument is included, the object specified
    by the first argument is duplicated and converted to the specified
    organization.

 See Also:
    bil(), bip(), bsq()

?functions format()
?format() 
 format()  - Show or change an objects data format

 format(object=VAL [, format={BYTE,SHORT,INT,FLOAT,DOUBLE}])

    The format() function reports or changes the data format of an
    object.  If used with only one argument, the data format of the
    object specified by the argument is reported as a string.  The
    return values are one of:

        "byte"   - 8 bit unsigned integer
        "short"  - 16 bit signed integer
        "int"    - 32 bit signed integer
        "float"  - 32 bit real
        "double" - 64 bit real

    If the second, optional, argument is included, the object specified bt
    the first argument is duplicated and converted to the specified format.

 See Also:
    byte(), short(), int(), float(), double()

?functions dim()
?dim()
 dim() - Show an objects size

 dim(object=VAL)

    The dim() function reports the size of each axis of an object.
    The values are returned in a 3x1x1 array, as the size of the 
    X, Y and Z axis, respectivly.

?functions bsq()
?bsq()
 bsq() - Convert an object to BSQ organization

 bsq(object=VAL)

    The bsq() function copies and converts an object to BSQ organization.
    This function is equivalent to org(object=VAL, org=BSQ).

 See Also:
    bil(), bip(), org()

?functions bip()
?bip()
 bip() - Convert an object to BIP organization

 bip(object=VAL)

    The bip() function copies and converts an object to BIP organization.
    This function is equivalent to org(object=VAL, org=BIP).

 See Also:
    bil(), bsq(), org()

?functions bil()
?bil()
 bil() - Convert an object to BIL organization

 bil(object=VAL)

    The bil() function copies and converts an object to BIL organization.
    This function is equivalent to org(object=VAL, org=BIL).

 See Also:
    bsq(), bip(), org()

?functions byte()
?byte()
 byte() - Convert an object to BYTE format

 byte(object=VAL)

    The byte() function copies and converts an object to BYTE format.
    Any values above or below the maximum representable values of
    0, 255 are set to the nearest representable value.
    This function is equivalent to format(object=VAL, format=BYTE).

 See Also:
    short(), int(), float(), double(), format()

?functions short()
?short()
 short() - Convert an object to SHORT format

 short(object=VAL)

    The short() function copies and converts an object to SHORT format.
    Any values above or below the maximum representable values of
    -32767,32768 are set to the closest representable value.
    This function is equivalent to format(object=VAL, format=SHORT).

 See Also:
    byte(), int(), float(), double(), format()

?functions int()
?int()
 int() - Convert an object to INT format

 int(object=VAL)

    The int() function copies and converts an object to INT format.
    Any values above or below the maximum representable values of
    -2^31,2^31 are set to the closest representable value.
    This function is equivalent to format(object=VAL, format=INT).

 See Also:
    byte(), short(), float(), double(), format()

?functions float()
?float()
 float() - Convert an object to FLOAT format

 float(object=VAL)

    The float() function copies and converts an object to FLOAT format.
    The behavior of float() when dealing with values out of the 
    representable range, 1.4e-45 to 3.4e38, is undefined.
    This function is equivalent to format(object=VAL, format=FLOAT).

 See Also:
    byte(), short(), int(), double(), format()

?functions double()
?double()
 double() - Convert an object to DOUBLE format

 double(object=VAL)

    The double() function copies and converts an object to DOUBLE format.
    The behavior of double() when dealing with values out of the 
    representable range, 1.7e308 to 4.9e-324 is undefined.
    This function is equivalent to format(object=VAL, format=DOUBLE).

 See Also:
    byte(), short(), int(), float(), format()

?functions cat()
?cat()
 cat() - Concatenate (append) two objects together

 cat(ob1=VAL,ob2=VAL,axis={X,Y,Z})

    The cat() function duplicates ob1 and appends a copy of ob2, along the 
    specified axis.  The two objects must match in format and organization, 
    and must have the same dimension along the two unspecified axis.

 See Also:
    format(), org(), dim(), //

?functions clone()
?clone()
 clone() - Duplicate an object many times.

 clone(object=VAL [,x=INT] [,y=INT] [,z=INT])

    The clone() function dupicates the specified object X*Y*Z times, and
    concatenates these objects together the specified number of time along
    each axis.  Any of the X, Y or Z values that are not specified defualt
    to a value of 1.

 See Also:
    cat()

?functions read()
?read()
 read() - Load a data from file

 read(filename="path" [,record=INT],
      [,xlow=INT] [,xhigh=INT] [,xskip=INT]
      [,ylow=INT] [,yhigh=INT] [,yskip=INT]
      [,zlow=INT] [,zhigh=INT] [,zskip=INT])

    The read() function loads the specified data file.   The read() 
    function can automatically recognize and load the following file 
    formats:
        SpecPR_FS2
        VICAR
        PDS/ISIS Qube and Image
        PBMPlus: PBM, PGM and PPM formats
        USGS GRD
        Imath
        GOES weather satellite
        AVIRIS
        GIF, JPEG, TIFF, PNG, BMP
        HDF5

    If the specified path is not absolute (ie: it doesn't start with a '/'),
    and the specified file cannot be found in the current directory, the
    DATAPATH variable is used as a list of directories to additionally search.
    The specified path is appended to each directory listed in the DATAPATH
    variable.

    If the variable VERBOSE is set to a value greater than zero, details of
    the file loading process are printed to stderr.  Higher values (up to 3)
    produce more output.

    The record value is required for SpecPR files.  If it is given with 
    another file type, it is used as the high and low value for a Z axis 
    subset, causing a single image to be extracted from cubes.

    The values low, high and skip can be specified for each axis (ie: xlow,
    zhigh, etc) to specify a precise subset to be read.  All the subsetting
    arguments are optional.

    Reading a PPM image produces a 3-plane, BIP cube of byte values.
    Each plane represents the red, green and blue values respectivly.

    The functions load() and import() are aliases for the read() function.

 See Also:
    write(), filetype(), load_pds(), load_raw(), load_vanilla(), 
    ascii(), isis(), datapath, verbose

?functions write()
?write()
 write() - Save data to file

 write(object=VAL, filename="path", type=TYPE, force=1)

    The write() function copies data to a file.  The value of type specifies 
    the type of file written, and is one of: 

        specpr  - SpecPR
        vicar   - Vicar grayscale
        grd     - USGS Grid
        pgm     - Pbmplus 8-bit grayscale
        ppm     - Pbmplus 24-bit true-color
        isis    - PDS/ISIS
        ascii   - Columnar ascii matrix
        imath   - Imath format
        ers     - ER Mapper Raster
        gif     - Compuserve GIF format
        tiff    - Tagged Image File Format
        jpeg    - Joint Photographic Experts Group
        png     - Portable Network Graphics
        bmp     - Microsoft Bitmap
        raw     - Binary output, no header
    
    If the force keyword is included, then any existing file of the same
    name is overwritten.  Without this keyword, the write is aborted
    if the filename already exists.

    Notes: 
        The standard graphics formats (GIF, TIFF, JPEG, PNG, BMP, PPM),
        all expect either 1 or 3 band, byte images.  A 3-band image is
        interpreted to be a red band, a green band and a blue band.

        The PGM and GRD formats can not handle multiplane data.

        The ERS format produces two files, one named "path", containing the
        raw raster data, and another named "path.ers", containing the ERS
        header.  This is the standard for ERS files.

 See Also:
    filetype(), read(), rgb(), load_pds(), load_raw(), ascii(),
    write_isis()

?functions filetype()
?filetype()
 filetype() - Determine the type of a file

 filetype(filename="path")

    The filetype function returns the type of a data file.  The filetype
    function returns the following strings for each type recognized:
        "SPECPR" - Specpr_FS2
        "VICAR"  - VICAR
        "GRD"    - USGS GRD
        "ISIS"   - PDS/ISIS
        "PNM"    - PBMPlus 
        "AVIRIS" - AVIRIS
        "IMATH"  - VM IMath format
        "ENVI"   - ENVI format

    The output from the filetype() function is suitable for input to the
    type value of the write() function.

    This funCtion is almost always not up to date with the latest stuff.

?functions source()
?source()
 source() - Execute a script file

 source(filename="path")

    The source function executes the specified file exactly as if its
    contents has been typed as input, with the exception that the commands
    are not stored in the log file, although the source() command is.

    Executing scripts that call source is allowed.  The only limit on the
    number of files that can be open is imposed by the operating system.

?functions atoi()
?atoi()
 atoi() - Convert a string to INT

 atoi(STRING | TEXT)

    The atoi function converts the specified string to an INT value.
    If the input is a TEXT array, then each line of the TEXT array is 
    converted and an array of 1xNx1 values is returned.

 See Also:
    atof()

?functions atof()
?atof()
 atof() - Convert a string to FLOAT

 atof(STRING | TEXT)

    The atof function converts the specified string to a FLOAT value.
    If the input is a TEXT array, then each line of the TEXT array is 
    converted and an array of 1xNx1 values is returned.

 See Also:
    atoi(), atod()

?functions atod()
?atod()
 atod() - Convert a string to DOUBLE

 atod(STRING | TEXT)

    The atod function converts the specified string to a DOUBLE value.
    If the input is a TEXT array, then each line of the TEXT array is 
    converted and an array of 1xNx1 values is returned.

 See also:
    atof(), atoi()

?functions basename()
?basename()
 basename - Return file portion of a path/file string.

 basename(obj=STRING | TEXT, [ext = STRING])

    The basename function searches the specified string for the last
    occurance of the '/' character, and duplicates and returns
    everything after it.  If the '/' character does not appear in
    the string, the entire string is duplicated and returned.

    The basename function is identical to the unix command of the same name.  

    if ext is used, then the ending substring which matches ext is
    removed.

 See also:
    dirname()

?functions cluster()
?cluster()
 cluster - Windowing cluster detection

 cluster(object=VAL [,radius=INT] [,threshold=INT])

    The cluster() function generates a 'windowed cluster overlay', from a
    source image.  Each pixel of the overlay represents the number of
    neighboring pixels in the source image.  A pixel is considered to be a
    neighbor if it is within radius pixels, and has a value above threshold.

    The source image must be a BYTE, SHORT or INT image, with a depth of 1.

 See Also:
    ccount()

?functions ccount()
?ccount()
 ccount() - Count pixels in a cluster overlay

 ccount(object=VAL [,threshold=INT] [,ignore=INT])

    The ccount() function is used to count the number of pixels in a 
    cluster overlay that have a value above the specified threshold.  

    Ccount() returns a 3x1x1 array of FLOAT values representing:
        The ratio of the next two values,
        The number of pixels in the overlay with a value above threshold,
        The total number of pixels in the image with a value above ignore.

 See Also:
    cluster()

?functions rgb()
?rgb()
 rgb() - Generate a 3-plane RGB image.

 rgb(red=VAL,green=VAL,blue=VAL)

    The rgb() function duplicates the three specified objects, and
    concatenates them together into a 3-band BIP cube, suitable for
    output as a PPM image.

    Each image must be an BYTE image and have the same X and Y dimensions.

 See Also:
    write()

?functions translate()
?translate()
 translate() - translate an object along specified axis

 translate(object=VAL,from={x,y,z},to={x,y,z},flip=1)

    The translate function translates the specified object along the
    from the 'from' axis to the 'to' axis.  (ie: from X to Y).  If
    the 'flip' keyword is included (with any value), the specified
    axes are copied in descending instead of ascending order.

    The following example translates the specified image from the
    +X to the -Y axis, effectivly rotating the image counter-clockwise
    in the X-Y plane.

    Example:
       dv> translate(object=image, from=x, to=y, flip=1)

?functions ascii()
?ascii()
 ascii() - Load an ASCII columnar file

 ascii(filename="PATH",x=INT,y=INT,z=INT,format=TYPE,column=INT,row=INT,delim=STRING)

    The ascii() function loads data from an ASCII columnar (matrix) file.  
    The data is assumed to be in BSQ organization.

    Pixel values on a line must be separated by at least one space or 
    tab.  Lines must be seperated by exactly 1 newline, and planes
    must be seperated by one (1) blank line.

    The only required keyword is 'filename'.  If any of the X, Y or Z
    values are omitted, they are assumed to be 1, unless all are omitted,
    in which case the file is pre-scanned to attempt to determine its
    size.

    'Format' determines the output type of the data.  TYPE is one of:
    'byte', 'short', 'int', 'float', or 'double'.  If format is omitted,
    the default output type is FLOAT.  Floating point values cannot be
    read using a type of 'byte', 'short' or 'int'.

    The value 'row' specifies the number of lines to skip before trying
    to read any data.  The value 'column' specifies the number of values
    to skip for every line read.

    The 'delim' parameter defines the list of column delimiters to use.
    If this option is omitted, the both TAB and SPACE are used as delimters.
    The value for 'delim' should always be enclosed in quotes.

?functions Math
 Davinci supports the usual complement of floating-point math functions.
 Each of these functions returns a FLOAT.

?functions Math sin()
?sin()
 sin() - Trigonometric sine

 sin(VAL)

    Computes the trigonometric sine of the input value.

?functions Math cos()
?cos()
 cos() - Trigonometric cosine

 cos(VAL)

    Computes the trigonometric cosine of the input value.

?functions Math tan()
?tan()
 tan() - Trigonometric tangent

 tan(VAL)

    Computes the trigonometric tangent of the input value.

?functions Math asin()
?asin()
 asin() - Trigonometric arc-sine

 asin(VAL)

    Computes the trigonometric arc-sine of the input value.

?functions Math acos()
?acos()
 acos() - Trigonometric arc-cosine

 acos(VAL)

    Computes the trigonometric arc-cosine of the input value.

?functions Math atan()
?atan()
 atan() - Trigonometric arc-tangent

 atan(VAL)

    Computes the trigonometric arc-tangent of the input value.

?functions Math floor()
?floor()
 floor() - Round down

 floor(VAL)

    Rounds down to the nearest integer value.  Produces FLOAT value.

?functions Math ceil()
?ceil()
 ceil() - Round up

 ceil(VAL)

    Rounds up to the nearest integer value.  Produces FLOAT value.

?functions Math abs()
?abs()
 abs() - Absolute value

 ceil(VAL)

    Returns absolute value of input value.

?functions Math exp()
?exp()
 exp() - Exponential function

 exp(VAL)

    Returns exponential function, e^x

?functions Math log()
?log()
 log() - Base e logarithm

 log(VAL)

    Returns natural logarithm of input value.  Input value must be positive

?functions Math log10()
?log10()
 log10() - Base 10 logarithm

 log10(VAL)

    Returns base 10 logarithm of input value.  Input value must be positive

?functions Math pow()
?pow()
 pow() - Compute x raised to the power y

 pow(x,y) 

 Computes x raised to the power y.

?functions help()
?help()
 help - Online help function

 help topic
 ? topic

    This is the online help system.

?functions moment()
?moment()
 moment() - Compute standard statistics (min,max,mean,adev,sdev,var,skew,kurt)

 moment(VAL)

    Computes the following statistics for the input value, and returns
    them (in the specified order) in a 8x1x1 FLOAT array:

         minimum value,
         maximum value,
         mean,
         average deviation,
         standard deviation,
         variance,
         skewness,
         kurtosis.


?functions display()
?display()
 display() - Display a grayscale image

 display(VAL)


    The display function passes the specified argument to an external
    viewer, as a grayscale image.

?functions xplot()
?xplot()
 xplot - Plot one or more objects, and supply an optional X-Axis

 xplot([axis={X,Y,Z}],[Xaxis=VAL],VAL1,[VAL2...])

    The xplot function will take a data block (or several data blocks)
    and plot them using axis as a kind of delimiter.  Example:
        a=create(1,7,20)
        xplot(a, axis=Y)

    will create a set of 20 data plots (all the same color) of 7 data 
    points each.  Alternatively:
        xplot(a,axis=Z) 

    will reate a set of 7 data plots (all the same color) of 20 data points
    each.  To seperate data sets (in terms of color/symbol) then specify
    them as different objects:
        xplot(a1,a2,axis=Y)

    will produce (on the same graph) two plots of 20 data sets of 7 data
    points each (assumeing a1 and a2 have the same configuration as our
    original a).

    An X-Axis can also be specified to provide a horizontal scale of
    a particular nature:
    
        MyAxis=create(1,7,1,format=float)
        MyAxis=MyAxis/max(MyAxis) /*My Axis is now 0->1 in 7 steps */
        xplot(axis=Y,a,a1,a2,Xaxis=Myaxis)

    Now we will get three color plots of 20 data sets (each) of 7
    data points each and the X-axis will go from 0 to 1 in seven steps.

    Alternatively, we could have specified MyAxis as follows:

        MyAxis=create(1,7,20,format=float)

    Now there is an X-axis per data set (NOTE: this can be abused so use
    with caution).

?functions gplot()
?gplot()
 gplot() - Plot an object

 gplot(VAL)


    The gplot function passes the specified argument to an external
    plotting program (gnuplot).  The data is passed as it is stored
    in memory.

?functions interp()
?interp()
 interp() - Point interpolation

 interp(object=VAL,from=VAL,to=VAL)


    The interp() function performs a point interpolation.  OBJECT is 
    interpolated from the FROM object to the TO object, taking OBJECT
    as the Y data values, and FROM as the corresponding X values.

    OBJECT and FROM must contain the same number of elements.  The low
    and high values of TO must reside entirely within the low and high
    values of FROM.

    Note:  A lot of people get confused by this description.  Lets try again:

    OBJECT is a set of Y values.
    FROM is a corresponding set of X values.
    TO is one or more new X values to look up from the FROM/OBJECT pairs.

?functions fit()
?fit()
 fit() - Least squares curve fitting

 fit(y=VAL, x=VAL, steps=INT, type=STRING, plot=BOOL, start=VAL, ignore=VAL)

    The fit() function performs a non-linear least-squares fit to a data
    set, using the user specified function type.  Currently, only
    the following four functions are implemented:

        gauss       f(x) = a2 * exp(-((a0-x)/a1)**2)
        gaussc      f(x) = a2 * exp(-((a0-x)/a1)**2) + a3
        gaussl      f(x) = a2 * exp(-((a0-x)/a1)**2) + a3 + a4*x
        linear      f(x) = a0 + a1*x
        quad        f(x) = a0 + a1*x + a2*x*x
        cube        f(x) = a0 + a1*x + a2*x*x + a3*x*x*x

    The fit() function uses an iterative method to find the best fit,
    however by default, only one iteration is performed.  The user can
    specify a larger number of iterations with the 'steps' parameter, or
    the fit() function can be called repeatedly, using the return values
    from the previous call as the start parameter for the next call.

    If no start parameter is specified, or any of the start parameters are
    zero, fit() makes a guess based on the function selected and the 
    actual data values.  (The marquant-levy fitting method can not handle
    zero coefficients.)

    If the X data values are not specified, channels are used instead, 
    starting at 0.

    The fit() function returns an array of DOUBLEs containing the
    function coefficients, the the chi-squared 'goodness-of-fit'
    value, and the alamda necessary for the next iteration.  The
    order of these values is defined by the function type selected.

    The returned coefficients array is suitable for use as the start values
    for another iteration of the fit() function.

    If the plot keyword is given and is non-null, then the data, and the 
    fitted function are plotted.

?functions vignette()
?vignette()
 vignette() - Generate vignetting correction image

 vignette(width=INT, height=INT, radius=FLOAT, offset=FLOAT, intensity=FLOAT)

    The vignette() function generates a vignetting correction image.
 
    The width and height parameters specify the size of the image.
    Radius, offset and intensity specify the values of the variables
    in the vignetting function:
 
         cx = width/2;
         cy = height/2;
         r =  sqrt((i-cx)*(i-cx) + (j-cy)*(j-cy))
         a[i,j] = intensity * cos((r/radius) * (pi/2))) + offset
    
    The returned image is of type FLOAT

?functions bop
?bop
 bop - binary operator functions

 Binary operator functions take exactly 2 inputs, operate on them in the 
 same way math operators work, and return a double.

 The functions covered by bop are:

 bbr()   - Generate black-body curves 
 btemp() - Compute brightness temperature

?functions bbr()
?bbr()
 bbr() - Generate black-body curves

 bbr(wavelength, temp)

    The bbr() function is a binary operator function (see bop).

    The bbr() function computes the black-body curve corresponding
    to the specified temperature, for the given wavelength(s).

    Wavelengths are assumed to be in units of wavenumber (1/cm).

    The bbr() function returns a DOUBLE.

 See also:
    btemp(), bop()

?functions btemp()
?btemp()
 btemp() - Compute brightness temperature

 btemp(wavelength, radiance)

    The bbr() function is a binary operator function (see bop).

    The btemp() function computes the brightness temperature of
    the given radiance(s) at the specified wevelength(s).

    Wavelengths are assumed to be in units of wavenumber (1/cm).

    The btemp() function returns a DOUBLE.

 See also:
    bbr(), bop()

?functions ifill()
?ifill()
 ifill() - Interpolated image fill

 ifill(object=VAL, radius=INT, fill=VAL)

    The ifill() function 'fills in gaps' in an image.
    
    The input image is searched a strip at a time in a particular
    scan direction, searching for values equal to the fill value.
    If a run of 1 or more pixels of the fill value are found, and
    the run does not extend more than <radius> pixels, the fill
    values are replaced with values interpolated from the non-fill
    values bordering the gap.

    This process is repeated 4 times, corresponding to scan directions
    running north/south, east/west, ne/sw, and nw/se.  The 4 images
    are averaged together, ignoring any remaining fill values, and
    the non-fill values from the original image are copied in place.

    The <radius> value defaults to 3.
    The <fill> value defaults to 0.

?functions jfjll()
?jfjll()
 jfjll() - Phil's filling routine

 ifill(object=VAL, radius=INT, fill=VAL, wrap=BOOL, neighbors=INT)

    The jfjll() function 'fills in gaps' in an image.
    
    The input image is searched for holes (values equal to the fill value).
    For each hole, the input image is scanned in 8 directions for non-fill
    values.  If <neighbors> non-fill values are found within <radius> pixels,
    a weighted average of these values is used to fill in the hole.

    The weighting used is r*r.

    The value <radius> defaults to 3.
    The value <fill> defaults to 0.
    The value <neighbors> defaults to 5.

?functions pause()
?pause()
 pause() - Get a line of input from the user
 
 pause(string)

 The pause() function prints its argument (without a newline), and
 waits for a line of input from the user, which is returned by the
 function as a string.

 Example:

    while (1) {
        s = pause("Enter a number, or press return to exit:\n")
        if (strlen(s) <= 1) break
    }

?functions printf()
?printf()
 printf() - print formatted output

 printf(fmt [, argument...] )

 The printf() function is a direct interface to the C library function
 of the same name.  
 
 Printf returns no value.

?functions sprintf()
?sprintf()
 sprintf() - print formatted output to a string

 sprintf(fmt, ... )

 The sprintf() function is a direct interface to the the C library
 function of the same name, except that the the output string is 
 returned, not passed.

 Example:

    s = sprintf("The value of 3+4 is %d\n", 3+4)

?functions fprintf()
?fprintf()
 fprintf() - print formatted output to a file

 fprintf(filename, fmt, ... )

 The fprintf() function works exactly like the sprintf function,
 but appends its output to specified filename.

 Notes: This is such a hack.

?functions system()
?system()
 system() - issue a shell command.

 system(cmd)

 The system() function executes the specified command string using the
 C library system() call, and returns when the command exits.

 The system() function returns no value.

 Example:

    system("ls -l");


?functions fsize()
?fsize()
 fsize() - return file size

 fsize(filename)

 The fsize() function determines the size of the specified file, and
 returns that number as an integer.  If the file does not exist, fsize()
 returns a -1.

 Example:

    fsize("/etc/passwd")


?functions avg()
?avg()
 avg() - Compute average along specified axis

 avg(object=VAL, axis=[x][y][z], [both=BOOL], [ignore=VAL])

 The avg() function computes the statistical average along one or
 more axis.  If no axis is specified, then the average is computed
 along all three.  avg() always returns a FLOAT.

 If an ignore value is specified, then any element that is equal to
 the ignore value is not included in the computation.  If all the
 values in the computation are equal to the ignore value, then the
 output is set to the ignore value.

 If the both flag is set (both=1), then avg returns a structure
 containing the both the avg and stddev.

 Example:

    This example computes the average along the X and Y axis, producing
    an array with the same Z dimension of the input data.

    dv> a = avg(object=data, axis=xy)

 Note: The avg function uses a one-pass accumulator that can experience
       round off error with lots of numbers.

?functions stddev()
?stddev()
 stddev() - Compute standard deviation along specified axis

 stddev(object=VAL, axis=[x][y][z], [both=BOOL], [ignore=VAL])

 The stddev() function computes the standard deviation along one or
 more axis.  If no axis is specified, then the standard deviation 
 is computed along all three.  stddev() returns a FLOAT.

 If an ignore value is specified, then any element that is equal to
 the ignore value is not included in the computation.  If all the
 values in the computation are equal to the ignore value, then the
 output is set to the ignore value.

 If the both flag is set (both=1), then stddev returns a structure
 containing the both the average and stddev.

 Example:

    This example computes the standard deviation the X and Y axis, producing
    an array with the same Z dimension of the input data.

    dv> sigma = stddev(object=data, axis=xy)

 Note: The stddev function uses a one-pass accumulator that can experience
       round off error with lots of numbers.

?functions sum()
?sum()
 sum() - Compute sum along specified axis

 sum(object=VAL, axis=[x][y][z])

     The sum() function computes the sum of values along one or more axis.  
     If no axis is specified, then all the summation is performed along
     all three axis.  Sum always returns a FLOAT.

 Example:

    This example computes the sum along the X and Y axis, producing
    an array with the same Z dimension of the input data.

    dv> a = sum(object=data, axis=xy)

?functions min()
?min()
 min() - Compute minimum value along specified axis

 min(object=VAL, axis=[x][y][z], ignore=VAL)

     The min() function finds the minimum value along one or more axis.  
     If no axis is specified, then all three axis are used.

	 If an ignore value is specified, then any element that is equal to
	 the ignore value is not included in the computation.  If all the
	 values in the computation are equal to the ignore value, then the
	 output is set to the ignore value.

     Min always returns a FLOAT.  This is not really the correct
     behaviour, but it is the easiest.

 Example:

    This example finds the minimum along the X and Y axis, producing
    an array with the same Z dimension of the input data.

    dv> a = min(object=data, axis=xy)

?functions max()
?max()
 max() - Compute maximum value along specified axis

 max(object=VAL, axis=[x][y][z])

     The max() function finds the maximum value along one or more axis.  
     If no axis is specified, then all three axis are used.

	 If an ignore value is specified, then any element that is equal to
	 the ignore value is not included in the computation.  If all the
	 values in the computation are equal to the ignore value, then the
	 output is set to the ignore value.

     Max always returns a FLOAT.  This is not really the correct
     behaviour, but it is the easiest.

 Example:

    This example finds the maximum along the X and Y axis, producing
    an array with the same Z dimension of the input data.

    dv> a = max(object=data, axis=xy)


?functions load_vis()
?load_vis()
 load_vis() - Load a VISIBLE Paci file

    load_vis(filename=STRING, [gse=1], [nocube=1], [verbose=0], [rotate=1])

    The load_vis function will read the four types of visible paci data that
    currently exitis: (gse, raw, predictive, DCT).  

    If the data contain multiple bands, then the routine will return a data
    cube with each band on a different Z-plane.  If the user wants a single
    band file then use: nocube=1 (defualt: nocube=0).  This will prevent the 
    reader from stacking the bands.

    There is a verbose mode which may be used.  This will increase the amount
    of information which davinci returns reguarding what is going on during
    the read.

    The final flag is the rotate flag.  Right now, it WILL rotate by default
    and the user must give a rotate=0 to prevent rotation (currently, only
    spacecraft data is rotated, gse is NOT).  Rotation involves horizontal and
    vertical flipping of EACH framelet (not the entire image). 


?functions load_paci()
?load_paci()
 load_paci() - Load an IR Paci file 

 load_paci(filename=STRING, [[frame=INT] | [band=int]], [report=1], [nosig=1],
                [swap=1],[quiet={0,1,2}])

    The load_paci function reads an IR paci file into memory and organizes in various
    ways depending on user input.  The user can specifiy a band OR frame number and only
    those data that match are loaded.  If the user sets report=1 then only a summary report
    is given back (and no data are loaded).  Each frame of data has 6 control values tacked
    on to the front of the frame and 2 value tacked on the back.  The first 2 values are the
    starting sync word, the next value is the ID, then band number then two numbers for the
    frame number.  The last two values are the ending sync value.  If the user does NOT
    want these values to be returned with the data, then use: nosig=1 (defualt is nosig=0).  

    There are two major forms for IR paci data, byte-swapped and NOT byte-swapped.
    If the data is from the Ratheon GSE (in Santa Barbara) then it is byte-swapped.
    Other-wise it is not.  If the data is NOT byte-swapped, swap=0 must be issued since
    swap=1 is the default value.

    Finally, various information about the condition of the data, missing information,
    skipped and/or repeated information is displayed.  To modify this a quiet value can
    be issued (defualt: quiet=0) with the following results:

        quiet=0:        Full reporting
        quiet=1:        Only print end summary
        quiet=2:        Print nothing except fatal errors

?history
     Davinci maintains a command line history.  As each line is typed, it
     is logged to a file in the current working directory, ".dvlog".  When
     davinci is started in an interactive session, this log file is preloaded
     into the command history.

     The history() command shows the contents of the history.

     You can copy lines from the history into a temporary file, which can
     then be edited, using the edit() function.

?history history()
?history()
 history() - Display command line history

 history(INT)

     The history() function displays the last N commands from the command
     line history.  If no argument is given, then the entire history is 
     printed to the screen.

 Example:

 This example displays the last 10 commands:

    dv> history(10)

?functions sort()
?sort()
 sort() - Sort an array of numbers

 sort(VAL)

     The sort() function sorts an array of numbers in ascending order,
     producing an array with the same format, organization and size of the
     orginal array.

?functions rgb2hsv()
?rgb2hsv()
 rgb2hsv() - Convert a 3-plane RGB image into HSV

 rgb2hsv(object=VAL, maxval=VAL)

     The rgb2hsv() function converts a 3-band RGB image into a 3-band
     HSV image.  If maxval is specified, it is taken to be the maximum
     intensity value.  If no value is specified for maxval, its value is
     determined from the input type.

     HSV values range from 0.0 to 1.0, so the return value has a type of
     FLOAT.


?functions hsv2rgb()
?hsv2rgb()
 hsv2rgb() - Convert a 3-plane HSV image into RGB

 hsv2rgb(object=VAL, maxval=VAL)

     The hsv2rgb() function converts a 3-band HSV image into a 3-band
     RGB image.  If maxval is specified, it is taken to be the maximum
     intensity value, and the RGB values are scaled to lie between 0 
     and maxval.  If no value is specified for maxval, it defaults to 1.

    The return value of hsv2rgb() has a type of FLOAT.

?functions histogram()
?histogram()

 histogram() - Generate a histogram

 histogram(object=VAL, 
           [start=FLOAT], [size=FLOAT], [steps=INT],
           [compress=BOOL], [normalize=BOOL], [cumulative=BOOL]);

 The histogram function sorts its input data into some number of bins, and
 produces a 2xN array of FLOATs as output.  The first column of the output
 contains the start value of each bin, and the second column contains the
 number of input values that fell in that bin.

 If the input object is in BYTE or SHORT format, the histogram will be
 auto-scaled to the 2^8 or 2^16 bins and each bin will have a width of 1.
 Otherwise, the user MUST provide at least the number of bins (steps)
 to be included in the histogram.

 If the start and size values aren't given, they are computed from the
 the minimum and maximum values of the input data.

 The compress options removes all bins with a value of 0.
 The normalize option divides each bin by the total number of elements.
 The cumulative option produces a cumulative histogram.

?functions hstats()
?hstats()

 hstats() - Generate statistics for a histogram

 hstats(object=VAL)

 The hstats() function generates statistics for 2 column input, like that
 produced by the histogram function.  A structure is returned containing
 the average and standard deviation for the input data.

?functions gnoise()
?gnoise()
 gnoise() - Generate a cube of mutually exclusive planes of noise.

 gnoise([x=INT],[y=INT],[z=INT],[seed=INT])

    The gnoise() function generates Z mutually exclusive planes of
    uniformly distributed noise.  For each X,Y location, exactly 1 pixel
    along the Z axis is set to a value of 1, producing images of 
    random noise with a frequency of 1/Z.  The value seed can be specified
    to seed the random number generator, to produce reproducable random
    numbers.  Any dimension not specified defaults to a value of 1.

 See Also:
    random(), rnoise()

?functions rnoise()
?rnoise()
 rnoise() - Generate a cube of pseudo-random, normally distributed, noise.

 rnoise([x=INT],[y=INT],[z=INT],[seed=INT])

    The rnoise() function generates a cube of the specified dimensions,
    of normally distributed random values.  The normal distribution has
    a standard deviation of 1.0.  A seed value can be specified to seed
    the random number generator, to produce reproducable random numbers.
    Any dimension not specified defaults to a value of 1.

 See Also:
    random(), gnoise()

?functions random()
?random()
 random() - Generate pseudo-random numbers

 random([x=INT],[y=INT],[z=INT],[seed=INT],[type=STRING)

    The random() function generates random numbers, with a distribution
    specified by the type parameter.

    The possible values for type, and the types of numbers generates are:

    type        distribution    type    interval
    -------     ------------    ----    ------------
    uniform     uniform         float   [0.0, 1.0)          # default value
    drand48     uniform         float   [0.0, 1.0)
    mrand48     uniform         int     [-2^31, 2^31)
    normal      gaussian        float   *
    gauss       gaussian        float   *
    rand        simple          int     [0, (2^15)-1]
    random      simple          int     [0, (2**31)-1]

    The gaussian distribution has a mean of 0.0, and a standard deviation
    of 1.0.

    The value seed can be specified to seed any of the random number 
    generators, to produce reproducable random numbers.  Any dimension 
    not specified defaults to a value of 1.

    Some of these types may not be available on all systems.

 See Also:
    rnoise(), gnoise()

?functions minvert()
?minvert()
 minvert() - Invert a square matrix
 
 minvert(VAR)
 
    The minvert() function inverts a square matrix using LU decomposition.
    The matrix must be square in the X and Y dimensions and the size of the
    Z dimension must be 1.

    The results from minvert() are always of type DOUBLE

 See Also:
    identity(), mxm()

?functions mxm()
?mxm()
 mxm() - matrix multiplication

 mxm(ob1, ob2) 

    Multiples ob1 by ob2 using matrix multiplcation.

 See Also:
    identity(), minvert()

?functions identity()
?identity()
 identity() - generate identity matrix

 identity(INT)

     Generate an identity matrix of the given size.

 See Also:
    mxm(), minvert()

?functions basis()
?basis()
 basis() - generate square transform basis function

 basis(object=VAL, type=STRING, size=INT)

    type: hadamard
          haar
?functions dct()
?dct()
 dct() - Compute dct along specified axis

 dct(object=VAL, axis=[x][y][z], dir=[1|-1])

     The dct() function computes the forward or inverse discrete cosine transform 
     of values along one or more axis.  If no axis is specified, then all the 
     computation is performed along all three axis.  If the direction is not
     specified, a forward dct is assumed.
     
     The dct() function always returns a DOUBLE.

 Example:

    This example computes the dct along the X and Y axis, producing
    an array with the same Z dimension of the input data.

    dv> a = dct(object=data, axis=xy)

?functions entropy()
?entropy()
 entropy() - Compute entrpy of object

 entropy(object=VAL)

     The entropy() function computes the entropy in an object,
     as sum(p * log2(p)), where p is the probability of each symbol
     occuring.  This is determined by sorting the values in the object
     and then counting them.

     The entropy() function always returns a FLOAT.

?functions plplot
    ALL plplot library  commands are availible to the user.  Several davinci commands
    were created to faciliate ease of use:
        popen() -   Define, initialize and open a window for plotting
        pplot() -   Plot a data cube along specified axis
        pprint()-   Print a current plot
        ptext() -   Flexible labeling tool
        pbox()  -   Set up limits and plot box with tick marks
        pline() -   Draw a set of connected line segments
        pzoom() -   Zoom in on a graph

?functions popen()
?popen()
 popen() - Define, initialize and open a window for plotting

 popen(xpos=INT, ypos=INT, xpixels=INT, ypixels=INT,title=STRING,portrait=int)

    This funtions opens up an X-Windows for plotting data using the
    plplot library.

    xpos is the initial x-position (relative to the desktop) of the new windows
    ypos is the initial y-position
    xpixels is the number of pixels columns
    ypixels is the number of pixels rows
    title is a string which can go in the window title bar
    portrait is a flag which define the graph as landscape 
    (portrait=0, default) or as portrait (portrait=1)

?functions pplot()
?pplot()
 pplot() - Plot a data cube along specified axis

 pplot(obj=VAL, axis={X,Y,Z}, 
       [append=INT, window=INT, Xaxis=VAL, color=int, 
        xhigh=FLOAT, xlow=FLOAT, yhigh=FLOAT, ylow=FLOAT])

 Pplot takes a dataset (obj) and plots it as a set of vector data
 along a specified axis.  Options include:

      append:  Draw over previous graph without erasing
    
      window:  ID of window to draw in.  Popen returns a integer ID value for 
               the window it creates.  Save this value if you open more 
               than one window.

      Xaxis:   Dataset object containing x-axis values.  Must be either 
                the same size as obj, or of size (X,1,1) where X is the 
                same value as the x-dimension of obj.

      color:   Ineger value between 0 and 15.  0 is the background color

      xhigh,xlow,yhigh and ylow can either be set by the user or 
                                automatically calculated if no value is given.
           
?functions pprint()
?pprint()
 pprint() - Print a current plot

 pprint(id=INT, title=STRING, type={ps,psc,pbm})

 pprint will create a printer file (or graphic file) of an already
 existing plot.  id specifies the window ID (as returned by popen) of
 the window to plot.  title is a string containing the filename for the
 printer file.  The type parameter sets what kind of file is produced:

        ps - b&w postscript file
        psc - color postscript file
        pbm - 640x480 graphics file (size is fixed)

?functions ptext()
?ptext()
 ptext() - Flexible labeling tool

 ptext(c=INT, e=FLOAT, x=FLOAT, y=FLOAT, angle=INT, 
       text=STRING, kolor=INT, world=INT)

  ptext prints labels and text on a plot allowing the user to specify
  a number of formating options.  Many of these options are here for
  MONGO graphing compatibility

    c:  (MONGO) text alignment relative to (x,y) position
    e:  (MONGO) text font expansion
    x & y: x and y position are specified in terms of normalized 
           coordinates (0,1)
    angle: (MONGO) integer value (in degrees) which specifies the 
           desired rotation of of the text
    text:   quoted string containing the text to put on the plot
    kolor:  integer value from 0 to 15 (0 is background color), set color 
            of ploted text
    world:  flag, if set to 1, x & y need to be in world coord. else 
            normalized (default)

?functions pbox()
?pbox()
 pbox() - Set up plot box with tick marks

 pbox(e=FLOAT, lt=INT, x=INT, y=INT, X=INT, Y=INT, m=INT, color=INT)
    pbox draws a box with tick marks and X & Y axis values.

    e:   text font expansion
    lt:  line thickness (defualt=1)
    x:   if non-zero, draw x-axis values (defualt)
    y:   if non-zero, draw y-axis values (defualt)
    X:   if non-zero, uses logrthymic values for x-axis
    Y:   if non-zero, uses logrthymic values for y-axis
    m:   if non-zero uses micron labeling for x-axis
        color : integer value between 0 and 15 (0 is background color)

?functions pline()
?pline()
 pline() - Draw a set of connected line segments

 pline(ls=INT,lt=INT, x=VAL, y=VAL, color=INT)

 pline plots set a of n points as n-1 conneted line segments, where xy 
 point n-1 is connected to xy point n, which is then connected to xy point n+1.

    ls: line style (0=solid (defualt), 1=dashed, >1 more dashed styles)
    lt: line thickness (defult =1)
    x:  dataset of x values (expected cube: (N,1,1)) N-number of points
    y:  dataset of y values (expected cube: (N,1,1)) N-number of points

        x & y must have the SAME number of points!

    color: integer between 0 and 15 (0 is the background color).

?functions pzoom()
?pzoom()
 pzoom() - Zoom in on a graph

 pzoom(x_lo=INT,x_hi=INT,y_lo=INT,y_hi=INT,Xv=VAL,Yv=VAL,reset=1)

    x_lo: new lower boundry for X-axis
    x_hi: new upper boundry for X-axis
    y_lo: new lower boundry for Y-axis
    y_hi: new upper boundry for Y-axis

                or
   Xv:Cube of dim(2,1,1); Xv[1,1,1]=x_lo; Xv[2,1,1]=x_hi
   Yv:Cube of dim(2,1,1); Yv[1,1,1]=y_lo; Yv[2,1,1]=y_hi

    reset=1 puts graph back original settings

?functions read_lines()
?read_lines()
 read_lines() - Read text file into text array object

 read_lines(filename=STRING)

  The read_lines() reads a text file and returns it as a TEXT array.

?functions dirname()
?dirname()
 dirname() - return the directory portion of a pathname

 dirname(object = STRING | TEXT)

  The dirname() function returns the directory portion of a path.
  When passed a TEXT array, it operates on each line of the TEXT array.

 See Also:
    basename()

?functions issubstring()
?issubstring()
 issubstring() - tests whether one string is a substring of another

 issubstring(targert = STRING, source = STRING)

  issubstring will return 1 if target contains source and 0 otherwise.

?functions delim()
?delim()
 delim() - return choosen collumn from delimted text

 delim(object = TEXT, delim = STRING, count = INT)

  delim returns collumn count as defined by delimiter delim from
  object.  The collumn is returned as a TEXT object with the
  same number of rows as object.

?functions grep()
?grep()
 grep() - search for the first occurrence of a pattern

 grep(object = TEXT, pattern = STRING)

  The grep() function copys each row of the passed TEXT object that 
  contains the specified pattern.  grep() supports regex patterns.

?functions strsub()
?strsub()
 strsub() - substring substitution using regular expressions
 
 strsub(object= STRING | TEXT, match = STRING, subst = STRING)

  strsub traverses a string looking for match and replaces it
  with subst.  For a TEXT object, this operation is done on
  everyrow using the same match and subst.  

  Note: match and subst can contain SED like regular expressions

  ex:
  strsub("xxxxxzzzxxxxxzzzxxxxxzzzxxxx","z\(z\)z","QQ\1QQ")
  will replace zzz with QQzQQ

  double back-slashes (\\) must be used within davinci

?functions strstr()
?strstr()
 strstr() - locate and return index of first occurence of substring

 strstr(obj= STRING | TEXT, pattern= STRING)

  strstr returns the index value where pattern begins in obj or 0
  if pattern is not in obj.  For a TEXT object a VAL is returned
  whoes size is [1,Row,1] where Row is the number of rows in
  the given text object.  

?functions syscall()
?syscall()
 syscall() - system's call
 
 syscall(STRING)

 syscall executes STRING in a command shell and returns any output
 in a TEXT object.

?functions xrt3d()
?xrt3d()
 xrt3d() - Display data using an XRT3D widget

 xrt3d(object=VAL, new=BOOL)

     The xrt3d() function displays data in an XRT3d window, creating the
     window if necessary.  If the keyword "new" is provided, a new window
     is always created, abandoning any previously created window.

     The XRT3d tool provides the following actions:

        Rotation:   
            Drag with Button2 and move clockwise or counter-clockwise.
                or
            Hold down Button2 and press x, y, or z to select an axis.  Then
            move the mouse perpendicular to that axis.
        
        Translation:
            Press Shift and drag with Button2 to shift the graph

        Scaling:
            Press Ctrl and drag with Button2. Move mouse down to zoom in, 
            and up to zoom out.
        
        Return to default:
            Press r to reset ann scaling, translations and zooming.

        Zoom:
            Press Ctrl and drag with Button1 to select the zoom area

        Pick:
            Click with Button1 to find nearest data point.
        
        Map:
            Click with Button3 to find the nearest point on the surface.

?functions projection()
?projection()
 projection() - Compute a stereographic projection for each band of an object

 projection(obj=VAL, [lat=FLOAT], [lon=FLOAT], [rad=FLOAT], 
            [ppd=INT], type=STRING)

 The projection() function will process each band of an object, projecting
 into a BIL organized dataset.  Format of the object does not matter.

 lat and lon specify the center point of the projection,
 rad specifys the radius extent of the projection in degrees.

 The ppd paramter specified pixels per degree, and when combined with
 the radius value, defines the size of the output image.  Therefore,
 if a radius of 20 is specified with ppd=5 the resulting band will be
 200 pixels (2x20x5) on each side.  
 
 The type parameter sets the parameters of distortion, that is if one 
 is projecting on the planet Mars as opposed to a sphere, there will 
 be a slightly different result.  The projection types are as follows:

    type: MARS
          EARTH
          SPHERE

 The four optional paramters default to the following values:
        
        lat=90.0
        lon=0.0
        rad=30.0
        ppd=1

 Example:

    dv> projection(obj=a,lat=0.0,rad=90,ppd=10,type=MARS)

    This will produce an equatorial projection (with lon defaulting to 0)
    with the poles at the top and botton of the image.  Each band will
    have the XY dimention of 1800 (2x90x10).

?functions Matrix
Davinci supports the following matrix functions:

    mxm()     - matrix multiply
    minvert() - matrix inversion
    convolve() - sliding window kernel convolution

?functions convolve()
?convolve()
 convolve() - Kernel convolution

 convolve(object=VAL, kernel=VAL, norm=BOOL)

    The convolve() function computes a sliding window kernel convolution.

    For each pixel in object, the weighted sum of the neighboring pixels
    is computed, with the weights being specified by the kernel.

    The norm parameter specifies whether or not each pixel is to
    be divided by the number of pixels used in the calculation.
    The neighborhood of edge pixels is smaller than center pixels.
    If norm=0, the edge pixels will be much smaller than the center
    pixels.  The default is norm=1.

    Example:

    The following kernel computes the average of a 3x3 neighborhood for 
    each pixel, smoothing the image.

        dv> b = clone(1, 3, 3, 1)
        1       1       1
        1       1       1
        1       1       1
        dv> convolve(img, b)

?functions convolve3()
?convolve3()
 convolve3() - Kernel convolution

 convolve3(object=VAL, kernel=VAL, norm=BOOL)

    Same as convolve, only a somewhat faster algorthm is used.
    
?functions create()
?create()
 create() - Create an array of values

 create(x=INT, y=INT, z=INT, [org=ORG, format=FORMAT, start=VAL, step=VAL])

     The create() function creates an array of data of the specified
     size, format and organization.

     The 'x', 'y' and 'z' parameters specify the size of each axis.
     If a value is not given, it is assumed to be 1.

     The 'org' and 'format' parameters specify the organization (one of
     bil, bip, bsq, xyz, xzy, zxy) and format (one of byte, short, int,
     float or double).  The default organization is bsq.  The default
     format is int.

     The array is filled with a ramp.  The first element is numbered from
     the 'start' parameter (default of 1) and each successive element is 
     incremented by the step size (default of 1).
     

 Example:

    This example creates a 3x3x1 image.  The elements are automatically 
    numbered from 1 to 9.

    dv> a = create(3,3,1)

?functions pcs()
?pcs()
 pcs() - Performs Principal Component Stretch of the given data

 pcs(obj=VAL [, opt={r|v|s}] [, axis={x|y|z}] [, scale=VAL] [, niter=INT])

        The pcs() function performs a Principal Component Stretch on the
        input data.
         
        The 'opt' parameter selects the statistical method to be used on
        the input data for the whole analysis. Various values taken by
        this parameter have the following meaning:

            'v' (default) - chooses Principal Component Analysis based on
                the covariance matrix
            
            'r' - chooses Principal Component Analysis based on the
                correlation matrix

            's' - chooses Principal Component Analysis based on the
                the "sum of cross products" matrix

        The 'axis' parameter specifies the dimension along with the
        vectors are laid out. Say, the input 'obj' is an [m x n x w]
        matrix and the 'axis' has been specified as 'z' then:

            'w' is the dimension of the a single input vector, and
            there are 'm x n' of them in the image cube.

            The default value for this parameter is 'z'.

        The 'scale' parameter specifies the scaling factor, if any, to be
        applied to the stretched vectors during the stretch phase. If 
        'scale' is not specified, it is assumed to be 1, i.e. no scaling.

        The 'niter' parameter specifies the maximum number of iterations
        allowed during Tridiagonal QL algorithm. If pcs() fails due to
        'no convergence' error, try increasing this number.


 Example:
    Assume that m1 is an image cube of dimensions [3x4x5], then the
    following line will do the principal component stretch of the
    input data based on the covariance matrix of 4x5=20 input vectors
    of dimension=3.

    dv> m2 = pcs(m1, v, x)

?functions covar()
?covar()
 covar() - Computes the Covariance matrix of the input data

 covar(obj=VAL [, axis={x|y|z}])

        The covar() function computes the covariance matrix for
        the vectors specified in the 'obj' cube.

        The 'axis' parameter specifies the dimension along with the
        vectors are laid out. Say, the input 'obj' is an [m x n x w]
        matrix and the 'axis' has been specified as 'z' then:

            'w' is the dimension of the a single input vector, and
            there are 'm x n' of them in the image cube.

            The default value for this parameter is 'z'.

 Example:
    Assume that 'm' is a data cube of dimensions [3x4x5], then the
    following line will compute the covariance matrix 'c' for the
    3x5=15 input vectors of dimension=4 each.

    dv> c = covar(m, y)

?functions corr()
?corr()
 corr() - Computes the Correlation matrix of the input data

 corr(obj=VAL [, axis={x|y|z}])

        The corr() function computes the correlation matrix for
        the vectors specified in the 'obj' cube.

        The 'axis' parameter specifies the dimension along with the
        vectors are laid out. Say, the input 'obj' is an [m x n x w]
        matrix and the 'axis' has been specified as 'z' then:

            'w' is the dimension of the a single input vector, and
            there are 'm x n' of them in the image cube.

            The default value for this parameter is 'z'.

 Example:
    Assume that 'm' is a data cube of dimensions [3x4x5], then the
    following line will compute the correlation matrix 'c' for the
    3x5=15 input vectors of dimension=4 each.

    dv> c = corr(m, y)

?functions scp()
?scp()
 scp() - Computes the sums of cross products matrix for the input data

 scp(obj=VAL [, axis={x|y|z}])

        The scp() function computes the sums of cross products matrix for
        the vectors specified in the 'obj' cube.

        The 'axis' parameter specifies the dimension along with the
        vectors are laid out. Say, the input 'obj' is an [m x n x w]
        matrix and the 'axis' has been specified as 'z' then:

            'w' is the dimension of the a single input vector, and
            there are 'm x n' of them in the image cube.

            The default value for this parameter is 'z'.

 Example:
    Assume that 'm' is a data cube of dimensions [3x4x5], then the
    following line will compute the sums of cross products matrix 'c'
    for the 3x5=15 input vectors of dimension=4 each.

    dv> c = scp(m, y)


?functions eigen()
?eigen()
 eigen() - Computes the Eigen Values and Eigen Vectors of a 
           Real Symmetric input matrix

 eigen(obj=VAL [, niter=INT])

        The eigen() function computes the Eigen Values and Vectors for
        a real symmetric [m x m x 1] matrix passed in as the 'obj'
        parameter.

        The 'niter' parameter specifies the maximum number of iterations
        allowed during Tridiagonal QL algorithm. If pcs() fails due to
        'no convergence' error, try increasing this number.


 Example:
    Assume that 'a' is a [3x3x1] matrix, then the following line
    will compute the Eigen Values and Eigen vectors of matrix 'a'.

    The return value 'e' is a [4x3x1] matrix, with the first column
    containing the Eigen Values and the next three columns containing
    the Eigen Vectors.

    dv> e = eigen(a)

?functions isis()
?isis()
 isis() - Enumerate or extract suffix planes of an ISIS cube

 isis(filename=STRING, [plane=STRING])
 isis(filename=STRING, [plane=INT, type={band,line,sample}]

 The isis() function decodes ISIS suffix planes.

 When called with just a filename, the isis() function will print
 details about the specified file, including the name and location
 of any suffix planes.

 Individual suffix planes can be extracted by name or by location,
 by speficying either a the plane's name or the plane's number.
 The plane's name can be abbreviated to the shortest unique prefix.

 The TYPE parameter is necessary when extracting planes by number.  
 It specifies which suffix to extract from.  Planes are numbered 
 starting from zero.
 
 Example:

 The following example extracts the plane named 'background' from the 
 file "my_file":

    dv> a = isis( filename="my_file", plane="background")
 
 This example extracts the band suffix plane #3: 

    dv> a = isis( filename="my_file", plane=3, type=band)


?functions load_vanilla()
?load_vanilla()
 load_vanilla() - Loads vanilla text output from a file

 load_vanilla(file=STRING [, delim=STRING])

  The load_vanilla() function loads a text output file generated
  by a run of vanilla. Fields with same names are combined into
  arrays and the data types are guessed from the data itself.

  The output is stored in a structure of parallel arrays of fields
  detected in the file. Field names are picked from the first line
  of the input file.

  Optional 'delim' character-string parameter may be specified 
  to enumerate field/column delimiters in the input file. Default
  delimiters are spaces and tabs.

  NOTE: load_vanilla() will work on text files with fixed number
  of columns per line. Thus, while selecting variable data fields,
  qualify them with indices, e.g. instead of saying "cal_rad[]"
  use some range of values, like, "cal_rad[3-144]".

 Example:

    The following command will load the vanilla output generated from an
    earlier vanilla run into a variable named 'a'. The data (stored in
    variable a) will be a structure of two fields, named, "sclk_time" and
    "temps". Each of these fields will be an array of 'n'-records. Where,
    'n' is the number of lines minus 1 (#lines - 1) in the input file.
    (#lines - 1: because the first line contains the header info)

    dv> system("vanilla ./data -fields 'sclk_time ick temps[1-4]' > /tmp/foo")

                    (some time later)
    
    dv> a = load_vanilla("/tmp/foo")
    struct, 3 elements
        sclk_time: 1x2x1 array of int, bsq format [8 bytes]
        ick: 1x2x1 array of int, bsq format [8 bytes]
        temps: 4x2x1 array of int, bsq format [32 bytes]

 Additional Notes:

  The vanilla output is TSV (tab separated values).  There's a one
  line TSV header containing the names of the columns.  Vanilla is
  capable of outputting variable length arrays, but the load_vanilla()
  function (and davinci in general) can't handle that output.  Instead,
  make sure to specify a range on arrays, such as 'array[1-143]'.

?functions fexists()
?fexists()
 fexists() - Determine if a file exists

 fexists(filename=STRING | TEXT)

 The fexists() function determines if a file exists or not.  

 If passed a single value, it will return 1 if the file exists and
 0 if it does not exist.

 When passed a TEXT array, it will return an array of values, one for
 each row of the input.

?functions length()
?length()
 length() - Determine the size of an object

 length(object)

 The length function returns the cardinallity of an object.

 For regular arrays, it returns the total number of values in the array.
 For strings, it returns the number of characters in the string.
 For structures, it returns the number of elements in the structure
 For text arrays, it returns the number of lines in the array.

 Example:

    dv> length(create(5,5,1))
    25
    dv> length("some string")
    11

?functions add_struct()
?add_struct()
 add_struct() - Add an element to a structure

 add_struct(object=STRUCT, name=STRING, value=VAL)

 The add_struct() function adds an element to a structure.  This 
 function is shorthand for "object.name = value", but in this case, 
 name can be a string variable.

 The add_struct() function returns the value argument.

?functions get_struct()
?get_struct()
 get_struct() - Get an element from a structure

 get_struct(object=STRUCT, name=STRING)

 The get_struct() returns an element from a structure.  This function is 
 shorthand for "object.name", but in this case, name can be a string 
 variable.

?functions remove_struct()
?remove_struct()
 remove_struct() - Remove an element from a structure

 remove_struct(object=STRUCT, name=STRING)

 The remove_struct() function deletes an element from a structure.  The
 deleted element is returned.

?functions insert_struct()
?insert_struct()
 insert_struct() - Insert an element in a structure at a given point

 insert_struct(object=STRUCT, name=STRING, value=VAL, [before=STRING|INT])
 insert_struct(object=STRUCT, name=STRING, value=VAL, [after=STRING|INT])

 The insert_struct() function adds an element to a structure at a specfied
 location.  The location can be specified as being either before or after
 another named element, or an index position.

 The name and value fields are optional.  Values inserted with no name
 simply have no name (they can only be accessed by position), and 
 names inserted with no value are given a value of zero.
 
?functions load_raw()
?load_raw()
 load_raw() - Load a binary data file

 load_raw(filename=STRING, x=INT, y=INT, z=INT, org=ORG, 
           format=FORMAT, header=INT)

 The load_raw() function allows a user to load uncompressed binary data
 by specifying relevent information about the file.  

 The x, y and z parameters specify the number of pixels in each axis.

 ORG must be one of "bil", "bip", "bsq".
 FORMAT must be one of: "byte", 
            "msb_short", "msb_int", "msb_float", "msb_double" , 
            "lsb_short", "lsb_int", "lsb_float", "lsb_double".

 The header value specifies the size, in bytes, of any header to be skipped.

?structures

  You can create anonymous structure (with no name) using the { } operators.
  Like this:
  	dv> x = { name=value, a=1, b="three" }.

  You can combine structures via addition: { one=1 } + { two=2 }

  You can read and write structures to disk with the optional HDF support
  library.

 See also:
    add_struct(), get_struct(), remove_struct(), insert_struct(), length()

?functions equals()
?equals()
 equals() - Determine if two things are the same

 equals(obj1, obj2)

 The equals() function checks every piece of obj1 and obj2 to see if the
 two objects are identical.  This works for VALs, STRINGs, TEXTs and 
 Structures.

 Equals() returns 1 if the two objects are identical, and 0 if not.

?functions contains()
?contains()
 contains() - Determing if an array contains a specific value

 contains(obj=VAL, value=VAL)

 The contains() function determine if an array contains a specific value.
 The value is converted to the same type as the array, so comparison of
 an integer array and a floating point number might produce unexpected 
 results.

 Contains() returns 1 if the specific value is found in the array, and 0
 if it isn't.

 Example:

    These examples return 1:

        contains(1//2//3, 3) 
        contains(1//2//3, 3.00001)   # note, the float is converted to an int

    These examples return 0:

        contains(1//2//3, 4) 
        contains(1.1//2.2//3.3, 3)

?functions dump()
?dump()
 dump() - Output an entire object

 dump(obj)

 The dump() function outputs every element of a VAL or TEXT, ignoring
 the usual 100 value, 10 line limits imposed by echo().

?functions dump()
?dump()
 dump() - Output an entire object

 dump(obj)

 The dump() function outputs every element of a VAL or TEXT, ignoring
 the usual 100 value, 10 line limits imposed by echo().

?functions global()
?globval()
 global() - Include a global variable in the current scope

 global(var)

 The global() function makes a named variable from the global scope available
 within the local scope (ie: inside a function).  Any changes made to the
 variable in the local scope affect the global variable directly.

 You cannot create a global variable in this manner.

 Note: global is all around not really safe to use.

?functions load_pds()
?io load_pds()
?load_pds()
 load_pds() - Read a PDS file into a structure

 load_pds(filename=PATH [, data=BOOLEAN])

 PDS files contain of NAME=VALUE pairs, and some rudimentary hierarchal
 structure via OBJECT and GROUP constructs.

 The load_pds() function understands a few common PDS data structures:
 	QUBE, SPECTRAL_QUBE, TABLE, IMAGE, HISTOGRAM_IMAGE and HISTORY.

 The DATA argument specifies whether or not to load the data from
 any objects encountered in the file.  (0=don't load, default is 1)

?functions coreg()
?coreg()
 coreg() - image coregistration

 coreg(i1, i2 [,search=INT][,random=INT][,ignore=INT])

    i1 and i2 must be 1-band images
    search - radius of the search window.  (default: 10)
    random - number of random samples to use (default: 1000)
    ignore - ignore value (background pixel color)

 The coreg() function performs a windowed search computing the square
 of the difference between a random pixel and it's NxN neighbors.

 If the "random" value is set to zero, an exhaustive search of every 
 pixel is performed.

 The function returns the X and Y offset of image1 into image 2.

?functions load_bin5()
?io load_bin5()
?load_bin5()
 load_bin5() - Loads data from a BIN5 file

 load_bin5(filename=PATH)

 BIN5 files are generated as an output from krc, the thermal
 intertia modeler. These files can have more than three
 dimensions.
 
 Let's assume that the number of dimensions in a given bin5
 file is represented by N. If N<=3 the data is returned as a
 3D-cube. If N>3 then cubes are formed out of the last three
 dimensions and concatenated in a hierarchy of structures as
 unnamed elements. For example, for a file with dimensions
 [W,X,Y,Z], the result will be a structure with W (unnamed)
 elements each of size [XxYxZ]. Similarly, for a file with
 dimensions [V,W,X,Y,Z], the result will be a structure with
 V (unnamed) sub-structures. Each sub-structure of V will be
 a structure with W (unnamed) elements each of size [XxYxZ].

 If the data were loaded into a variable called named "a",
 then a data element can be accessed in "a" as "a[w][x,y,z]"
 for the 4D case above and as "a[v][w][x,y,z]" for the 5D
 case above.

 Notes:
    A bin5 file has a text label (multiple of 512 bytes)
	which looks like:

    N d1 d2 .. dN Y E [L] <<... TIME>>TEXT ... ARCH C_END

	where,
	  N      is the number of dimensions,
	  d1..dN are the sizes of each dimension with the
	         most rapidly varying index first
	  Y      is the data type of individual data elements
	         1=byte, 2=short, 3=long, 4=float, 5=double,
			 12=ushort, 13=ulong (ref: IDL data types)
	  E      is the number of elements = d1*d2*..*dN
	  L      is the size of label (multiple of 512)
	  TIME   is the creation time of the file
	  TEXT   is the description associated with the file
	  ARC    is a 5-char value representing the machine on
	         which the data was written to this file,
			 supported values are "i386  " and "sun  "
	  C_END  is the sentinal which marks the end of label



