<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Davinci - GUI Module</title>
    <link rel="stylesheet" type="text/css" href="davinci.css"> 
  </head>

  <body>
    <h1 class="header">Davinci - GUI Module</h1>

    <h2>Contents</h2>

    <div class="box">

      <ul class="contents">
	<li><a href="#intro">Introduction</a></li>
	<li><a href="#started">Getting Started</a></li>
	<li><a href="#api">Module API</a></li>
	<li><a href="#widgets">Available Widgets</a></li>
	<li><a href="#basics">Basic Windows</a></li>
	<li><a href="#hello">Hello, world!</a></li> 
	<li><a href="#resources">Resource Manipulation</a></li>
      </ul>

    </div>

    <h2 id="intro">Introduction</h2>

    <div class="box">
      
      <p>The Davinci GUI module presents the developer with a limited set of Xt and Motif widget bindings, facilitating the construction of basic GUI-driven Davinci applications.</p>
      
      <p>Since the module widgets are based on Xt and Motif, most of the properties and behavior of the widgets are defined by the underlying Xt widget API.  Actions are handled via callbacks, and attributes via key-value pairs (implemented using Davinci structs).  All widgets are contained inside other widgets in a hierarchal fashion.</p>

      <p>This document assumes a basic familiarity with GUI concepts, specifically the X Window System and Xt/Motif widgets.  You will need a Motif reference in order to familiarize yourself with individual widgets and their attributes and callbacks.  The module author used O'Reilly &amp; Associates' X Window System series as the implementation reference.</p>

      <h3>Conventions</h3>

      <p>All Davinci code examples are in <code class="dv">monospaced magenta</code>.</p>
      <p>All Davinci output is in <code class="output">monospaced cyan</code>.</p>

    </div>

    <h2 id="started">Getting Started</h2>

    <div class="box">
      
      <p>Davinci must be built with module support at compile time, and the GUI module must be loaded before the bindings are available.</p>

      <h3>Module Location</h3>
      
      <p>Davinci will look for modules in its default installation directory (<code>/usr/local/lib/davinci</code>, if not changed at build time), or if the environment variable <code>DV_MOD_PATH</code> is set, in that directory.</p>

      <h3>Loading the Module</h3>

      <p>To load and initialize the GUI module, enter:</p>

      <p class="code">load_module(&quot;gui&quot;)</p>

    </div>

    <h2 id="api">Module API</h2>

    <div class="box">

      <div class="api">

	<p>The module presents the following functions to the developer:</p>
	<p class="smallfont"><i>(Redundant arguments are defined only once.  Optional arguments are in italic.)</i></p>

	<dl>

	  <dt>gui.create(widgetclass, <i>parent</i>, <i>resources</i>, <i>name</i>)</dt>
	  <dd>
	    <table>
	      <tr><th>widgetclass</th><td>Xt/Motif WidgetClass or Davinci alias.</td></tr>
	      <tr><th>parent</th><td>The <code>widgetid</code> of the parent widget.  Default is the application shell.</td></tr>
	      <tr><th>resources</th><td>A <code>struct</code> of resource key/values.</td></tr>
	      <tr><th>name</th><td>Arbitrary name for the widget.  Most widgets ignore this value.</td></tr>
	    </table>
	    <p>Create a new widget and return its handle.</p>
	  </dd>

	  <dt>gui.destroy(widgetid)</dt>
	  <dd>
	    <table>
	      <tr><th>widgetid</th><td>The handle of the widget to act on.</td></tr>
	    </table>
	    <p>Destroy <code>widgetid</code>.  This will recursively destroy all of the widget's children as well.  Any widgets which are realized (visible) when destroyed will be unrealized first.</p>
	    <p>Note that once a widget is destroyed, even if it's a child widget destroyed as a side-effect, its Davinci handle will no longer be valid and should not be used in any GUI module functions.</p>
	  </dd>

	  <dt>gui.get(widgetid, <i>resourcelist</i>, <i>all</i>)</dt>
	  <dd>
	    <table>
	      <tr><th>resourcelist</th><td>A list of resource names to retrieve.  Accepts <code>struct</code>, <code>text</code>, or <code>string</code>.</td></tr>
	      <tr><th>all</th><td>If <code>1</code>, return all resources, including hidden resources.</td></tr>
	    </table>
	  
	    <p>Retrieve the default list of resources, the resources specified in <code>struct</code> <i>resources</i>, or all widget resources if <code>all = 1</code> is specified.</p>
	    <p>Resources are returned in a Davinci <code>struct</code>.</p>
	  </dd>

	  <dt>gui.set(widgetid, resources)</dt>
	  <dd>
	    <p>Set one or more resources on the specified widget.</p>
	    <p>The resource names and values must be in a Davinci <code>struct</code>.  The struct from a <code>gui.get()</code> call may be modified and used in a <code>gui.set()</code> call.  You may also use anonymous structs.</p>
	  </dd>

	  <dt>gui.realize(widgetid)</dt>
	  <dd>
	    <p>Make the specified widget visible.  This recursively applies to all of the widget's children as well.</p>
	    <p>It is best to create an configure the widget and all its children before realizing the outermost widget, to avoid display problems.</p>
	  </dd>

	  <dt>gui.addcallback(widgetid, callback, eval)</dt>
	  <dd>
	    <table>
	      <tr><th>callback</th><td>The Xt callback name or Davinci alias.</td></tr>
	      <tr><th>eval</th><td>A piece of Davinci code to evaluate when the callback occurs.</td></tr>
	    </table>
	  
	    <p>Add the named callback to <code>widgetid</code>.  The code in <code>eval</code> must be a <code>string</code> of Davinci code, which we be evaluated each time the callback event occurs.  If you use a function name, arbitrarily complex Davinci functions can be executed.</p>
	  </dd>

	  <dt>gui.removecallback(widgetid, callback)</dt>
	  <dd>
	    <table>
	      <tr><th>callback</th><td>The Xt callback name or Davinci alias.</td></tr>
	    </table>
	  
	    <p>Remove the specified callback from <code>widgetid</code>.  The widget will no longer call any Davinci code when the callback occurs, however any internal callback handling will still occur (such as changing <i>RadioButton</i> states).</p>
	  </dd>

	</dl>

      </div>
    </div>

    <h2 id="widgets">Available Widgets</h2>

    <div class="box">

      <p>Many of the basic Xt and Motif widgets are available.  Some are implemented more completely than others.  In particular, complex widget resources (those accepting non-scalar values) are less likely to be implemented.  The best way to see which resources have been implemented is to create an instance of a WidgetClass you wish to use and run <code>gui.get(widgetid, all = 1)</code> on it.</p>

      <p>The following widgets are currently available with varying degrees of completeness:</p>

      <div class="widgetlist">
	<table>
	  <colgroup></colgroup>
	  <colgroup></colgroup>
	  <colgroup></colgroup>
	  <colgroup></colgroup>
	  <tr><th>Davinci Name</th><th>Xt Name</th><th>Description</th><th>Usability</th><th>Notes</th></tr>
	  <tr><td>arrowButton</td><td>XmArrowButton</td><td>Arrow-shaped push button</td><td>Complete</td></tr>
	  <tr><td>cascadeButton</td><td>XmCascadeButton</td><td>Menu support</td><td>None</td><td>Pending - menu implementation</td></tr>
	  <tr><td>command</td><td>XmCommand</td><td>Command entry dialog</td><td>Moderate</td><td>Needs testing</td></tr>
	  <tr><td>drawnButton</td><td>XmDrawnButton</td><td>Graphical push button</td><td>Low</td><td>Pending - Pixmap support</td></tr>
	  <tr><td>errorDialog</td><td>XmErrorDialog</td><td>Error message modal dialog</td><td>Low</td><td>Pending - Modal dialog support</td></tr>
	  <tr><td>fileSelectionBox</td><td>XmFileSelectionBox</td><td>File/directory selection dialog</td><td>Complete</td></tr>
	  <tr><td>form</td><td>XmForm</td><td>Layout manager - free-form</td><td>High</td></tr>
	  <tr><td>frame</td><td>XmFrame</td><td>Provides a window frame/border</td><td>Complete</td></tr>
	  <tr><td>label</td><td>XmLabel</td><td>Basic text label</td><td>High</td><td>Pending - Pixmap support</td></tr>
	  <tr><td>list</td><td>XmList</td><td>Basic ordered list</td><td>Complete</td></tr>
	  <tr><td>menuBar</td><td>XmMenuBar</td><td>Menu support</td><td>None</td><td>Pending - menu implementation</td></tr>
	  <tr><td>panedWindow</td><td>XmPanedWindow</td><td>Layout manager - vertical tiles</td><td>High</td><td>Needs testing</td></tr>
	  <tr><td>pushButton</td><td>XmPushButton</td><td>Generic push button</td><td>Complete</td></tr>
	  <tr><td>radioBox</td><td>XmRadioBox</td><td>Layout manager for radio buttons</td><td>High</td><td>Needs testing</td></tr>
	  <tr><td>rowColumn</td><td>XmRowColumn</td><td>Layout manager - grid</td><td>High</td></tr>
	  <tr><td>scale</td><td>XmScale</td><td>Sliding ranged value selector</td><td>High</td><td>Needs testing</td></tr>
	  <tr><td>scrollBar</td><td>XmScrollBar</td><td>Scrollbar</td><td>Moderate</td><td>Use ScrolledList/ScrolledWindow instead</td></tr>
	  <tr><td>scrolledList</td><td>XmScrolledList</td><td>List with automatic scrollbars</td><td>Moderate</td></tr>
	  <tr><td>scrolledWindow</td><td>XmScrolledWindow</td><td>Layout manager - scrollable area</td><td>Moderate</td></tr>
	  <tr><td>selectionBox</td><td>XmSelectionBox</td><td>List with item selection</td><td>Complete</td></tr>
	  <tr><td>separator</td><td>XmSeparator</td><td>Dividing line</td><td>Complete</td></tr>
	  <tr><td>text</td><td>XmText</td><td>Multi-line text entry window</td><td>Moderate</td><td>Needs testing</td></tr>
	  <tr><td>textField</td><td>XmTextField</td><td>Single-line text entry field</td><td>Complete</td></tr>
	  <tr><td>toggleButton</td><td>XmToggleButton</td><td>Boolean state button</td><td>Complete</td><td>Use inside RadioBox</td></tr>
	  <tr><td>topLevelShell</td><td>TopLevelShell</td><td>Framed &amp; titled window</td><td>Complete</td></tr>
	  <tr><td>transientShell</td><td>TransientShell</td><td>Modal dialog shell</td><td>Low</td><td>Pending - modal dialog support</td></tr>
	  <tr><td>vicar</td><td>xvicBasicImageWidget</td><td>Image display &amp; manipulation</td><td>High</td><td>Third-party Motif widget [<a href="vicar_widget.txt">Reference</a>]</td></tr>
	</table>
      
	<p>Most widgets marked <i>Moderate</i> are functional and tested, but some resources are not supported.  The primary unsupported resources are colors and pixmaps.</p>
      </div>

    </div>


    <h2 id="basics">Basic Windows</h2>

    <div class="box">

      <h3>ApplicationShell</h3>

      <p>All widgets must have a top-level parent.  When the GUI module is loaded, it will create a hidden top-level widget.  This is an Xt <i>ApplicationShell</i>.  Only one is created, and the developer cannot manipulate it or directly reference it.</p>

      <p>The <i>ApplicationShell</i> is the default widget parent, used when calling <code>gui.create()</code> with no parent specified.</p>

      <h3>TopLevelShell</h3>

      <p>The primary developer-controlled top-level widget is the Xt <i>TopLevelShell</i> widget.  It presents a window frame, title bar, and a container to hold other widgets.</p>

      <p>To create a <i>TopLevelShell</i> widget, enter:</p>

      <p class="code">top = gui.create(&quot;topLevelShell&quot;, name = &quot;My Davinci App&quot;)</p>

      <p>The value stored in <code>top</code> is a Davinci handle to the underlying Xt widget.  You do not need to save the handle, however it is the only way to reference the widget later.  Except in the case of simple <i>Label</i> widgets and the like, you'll need to save most handles.</p>

      <h3>TransientShell</h3>

      <p>Transient shells are used to implement modal dialogs and are currently not functional.</p>

    </div>

    <h2 id="hello">Hello, world!</h2>

    <div class="box">

      <p>The Davinci program below creates a simple window with a message in it:</p>

      <p class="code">
	load_module(&quot;gui&quot;)<br>
	top = gui.create(&quot;topLevelShell&quot;, name = &quot;Hello!&quot;)<br>
	label = gui.create(&quot;label&quot;, top, { labelString = &quot;Hello, world!&quot; })<br>
	gui.realize(top)<br>
      </p>

      <p>This example may be entered interactively, placed into an executable Davinci script, or placed in a file and executed via <code>source()</code>.</p>

      <p>Note that the interactive Davinci command prompt is still available while the GUI window is displayed.  Take care not to alter the widget handle variables while the widgets are in use.</p>

      <p>To destroy the window (and both widgets created), either destroy it in your window manager (usually by clicking <b>X</b> on the title bar), or enter:</p>

      <p class="code">gui.destroy(top)</p>

      <p>Either method will destroy the widgets completely.  While the variables <code>top</code> and <code>label</code> will still contain values, they will no longer be recognized as widget handles and should not be used.</p>

    </div>

    <h2 id="resources">Resource Manipulation</h2>

    <div class="box">

      <p>All resources manipulation is performed via Davinci <code>struct</code> variables.  The simplest resources are key/value pairs with scalar values, however arbitrarily complex objects can be used for compound resource values, such as lists of strings or multi-value feedback structures.</p>

      <h3>CSG: Create, Set, Get</h3>

      <p>While most resources can be manipulated at will, some can only be set at widget creation time, and become read-only thereafter, and some are always read-only and can never be changed by the developer.  In Xt reference guides, these resources are usually labeled in a <i>CSG</i> column, where <i>C</i>, <i>S</i>, and <i>G</i> are treated as flags.</p>

      <p>If you try to set a read-only resource, or set a create-only resource after creation time, the value will be ignored.  Refer to a Motif reference manual for details.</p>

      <h3>Resource Structure</h3>

      <p>Building on the &quot;Hello, world!&quot; example, the <i>labelString</i> resource could have been set by explicitly creating a struct, as below:</p>

      <p class="code">
	labelResources = struct()<br>
	labelResources.labelString = &quot;Hello, world!&quot;<br>
	label = gui.create(&quot;label&quot;, top, labelResources)<br>
      </p>

      <p>Either method is acceptable, but explicitly creating the struct will make your code cleaner when dealing with a large number of resources.</p>

      <h3>Setting Multiple Resources</h3>

      <p>To set multiple resources on a widget at once, add more elements to the structure:</p>

      <p class="code">
	labelResources = struct()<br>
	labelResources.labelString = &quot;Hello, world!&quot;<br>
	labelResources.alignment = &quot;ALIGNMENT_END&quot;<br>
	label = gui.create(&quot;label&quot;, top, labelResources)<br>
      </p>

      <p>If you modify the example and add the <i>alignment</i> resource, you will see that the label now &quot;sticks&quot; to the side of the side of the window when you expand it, instead of staying centered.</p>

      <h3>Querying Widget Resources</h3>

      <p>Once a widget has been created, you can query it at any time to obtain the current resource values.  The widget need not be realized.  Note that resource values may change as a side-effect of &quot;invisible&quot; user actions, such as resizing windows.</p>

      <p>To obtain the resources for our label widget:</p>

      <p class="code">
	resources = gui.get(label)
      </p>

      <p>If Davinci is in <i>verbose</i> mode, you will see the structure returned:</p>

      <p class="output">
	struct, 2 elements<br>
	alignment: &quot;ALIGNMENT_END&quot;<br>
	labelString: &quot;Hello, world!&quot;<br>
      </p>

      <h3>Resource Visibility</h3>

      <p>Calling <code>gui.get(widgetid)</code> will return only the default resources.  These resources are the ones most commonly associated with using the particular widget.  The default resource list is meant to be small and manageable, and can help developers learn what features a widget supports.</p>

      <p>Additional resources are available on every widget, and are normally hidden to reduce spam.  If you'd like to see all the widgets available, use <code>gui.get(widgetid, all = 1)</code>.  This will display all supported widget resources, including those inherited from parent widgets (more on that later).</p>

      <p>Running <code>gui.get(label, all = 1)</code> from our example yields:</p>

      <p class="output">
	struct, 30 elements<br>
	ancestorSensitive: &quot;true&quot;<br>
	sensitive: &quot;true&quot;<br>
	depth: 24	<br>
	mappedWhenManaged: &quot;true&quot;<br>
	numChildren: 1	<br>
	allowShellResize: &quot;true&quot;<br>
	saveUnder: &quot;false&quot;<br>
	overrideRedirect: &quot;false&quot;<br>
	title: &quot;Hello!&quot;<br>
	wmTimeout: 5000	<br>
	waitforwm: &quot;true&quot;<br>
	transient: &quot;false&quot;<br>
	baseWidth: -1	<br>
	baseHeight: -1	<br>
	minWidth: -1	<br>
	minHeight: -1	<br>
	maxWidth: -1	<br>
	maxHeight: -1	<br>
	widthInc: -1	<br>
	heightInc: -1	<br>
	minAspectX: -1	<br>
	minAspectY: -1	<br>
	maxAspectX: -1	<br>
	maxAspectY: -1	<br>
	iconX: -1	<br>
	iconY: -1	<br>
	clientLeader: -1	<br>
	urgency: &quot;false&quot;<br>
	iconName: &quot;Hello!&quot;<br>
	iconic: &quot;false&quot;<br>
      </p>

      <p>As you can see, a few resources were inherited from the parent, such as <code>title</code> and <code>iconName</code>.  Container and layout widgets all impart some resources on their children.  Most of these will never be used by the developer, hence the idea of &quot;default&quot; and hidden resources.</p>

      <p>Because some resource query operations may be costly (especially when images are involved), you can explicitly query specific resources.  To query a single resource:</p>

      <p class="code">
	gui.get(label, &quot;labelString&quot;)
      </p>

      <p>Which yields:</p>

      <p class="output">
	 struct, 1 elements<br>
	 labelString: &quot;Hello, world!&quot;<br>
      </p>

      <p>To query multiple resources, build a resource list in either a <code>struct</code>:</p>

      <p class="code">
	structlist = { "labelString", "alignment" }<br>
	gui.get(label, structlist)<br>
      </p>

      <p>...or a <code>text</code> object:</p>

      <p class="code">
	textlist = cat(&quot;labelString&quot;, &quot;alignment&quot;, axis = y)<br>
	gui.get(label, textlist)<br>
      </p>

      <p>Both produce the same output:</p>

      <p class="output">
	 struct, 2 elements<br>
	 labelString: &quot;Hello, world!&quot;<br>
	 alignment: &quot;ALIGNMENT_END&quot;<br>
      </p>

      <h3>Pseudo-Object-Oriented Access</h3>

      <p>A natural side-effect of Davinci structure access allows you to access resources in a manner familiar to object-oriented developers:</p>

      <p class="code">
	lstring = gui.get(label).labelString
      </p>

      <p>If you use this method, it's still a good idea to explicitly request the resource you need, for efficiency:</p>

      <p class="code">
	lstring = gui.get(label, "labelString").labelString
      </p>

    </div>

    <p style="text-align: right;">
      <a href="http://validator.w3.org/check/referer">
	<img border="0"
	     src="http://tes.asu.edu/~jim/valid-html401.png"
	     alt="Valid HTML 4.01!" height="31" width="88">
      </a>
      <a href="http://jigsaw.w3.org/css-validator/">
	<img style="border:0;width:88px;height:31px"
	     src="http://tes.asu.edu/~jim/vcss.png" 
	     alt="Valid CSS!">
      </a>
    </p>

  </body>
</html>
